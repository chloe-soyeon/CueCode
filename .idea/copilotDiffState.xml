<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/MotionService/src/main/java/kopo/motionservice/service/impl/MotionServiceImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/MotionService/src/main/java/kopo/motionservice/service/impl/MotionServiceImpl.java" />
              <option name="originalContent" value="package kopo.motionservice.service.impl;&#10;&#10;import com.github.kokorin.jaffree.ffmpeg.FFmpeg;&#10;import com.github.kokorin.jaffree.StreamType;&#10;import com.github.kokorin.jaffree.ffmpeg.UrlInput;&#10;import com.github.kokorin.jaffree.ffmpeg.UrlOutput;&#10;import kopo.motionservice.dto.MotionRecordRequestDTO;&#10;import kopo.motionservice.repository.RecordedMotionRepository;&#10;import kopo.motionservice.repository.document.RecordedMotionDocument;&#10;import kopo.motionservice.service.IMotionService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;&#10;import org.apache.hc.client5.http.impl.classic.HttpClients;&#10;import org.springframework.core.io.InputStreamResource;&#10;import org.springframework.http.HttpEntity;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.util.LinkedMultiValueMap;&#10;import org.springframework.util.MultiValueMap;&#10;&#10;import java.io.IOException;&#10;import java.io.PipedInputStream;&#10;import java.io.PipedOutputStream;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class MotionServiceImpl implements IMotionService {&#10;&#10;    private final RecordedMotionRepository recordedMotionRepository;&#10;&#10;    @Override&#10;    public void saveRecordedMotion(MotionRecordRequestDTO requestDTO) {&#10;        log.info(&quot;[MotionService] Manual Mapping - Saving recorded motion for phrase: {}&quot;, requestDTO.getPhrase());&#10;&#10;        // TODO: JWT 인증 구현 후, 토큰에서 실제 userId를 가져와야 합니다.&#10;        String mockUserId = &quot;user123&quot;;&#10;&#10;        // DTO -&gt; Document 수동 매핑 시작&#10;        MotionRecordRequestDTO.MotionDataDTO motionDataDTO = requestDTO.getMotionData();&#10;        RecordedMotionDocument.MotionDataDocument motionDataDocument = new RecordedMotionDocument.MotionDataDocument();&#10;&#10;        if (motionDataDTO != null) {&#10;            // face_blendshapes 수동 매핑&#10;            List&lt;RecordedMotionDocument.FaceBlendshapesFrameDocument&gt; blendshapesFrames = Optional.ofNullable(motionDataDTO.getFaceBlendshapes()).orElse(new ArrayList&lt;&gt;()).stream()&#10;                    .map(dtoFrame -&gt; {&#10;                        RecordedMotionDocument.FaceBlendshapesFrameDocument docFrame = new RecordedMotionDocument.FaceBlendshapesFrameDocument();&#10;                        docFrame.setTimestampMs(dtoFrame.getTimestampMs());&#10;                        docFrame.setValues(dtoFrame.getValues());&#10;                        return docFrame;&#10;                    }).collect(Collectors.toList());&#10;            motionDataDocument.setFaceBlendshapes(blendshapesFrames);&#10;&#10;            // hand_landmarks 수동 매핑&#10;            List&lt;RecordedMotionDocument.HandLandmarksFrameDocument&gt; landmarksFrames = Optional.ofNullable(motionDataDTO.getHandLandmarks()).orElse(new ArrayList&lt;&gt;()).stream()&#10;                    .map(dtoFrame -&gt; {&#10;                        RecordedMotionDocument.HandLandmarksFrameDocument docFrame = new RecordedMotionDocument.HandLandmarksFrameDocument();&#10;                        docFrame.setTimestampMs(dtoFrame.getTimestampMs());&#10;                        docFrame.setLeftHand(dtoFrame.getLeftHand());&#10;                        docFrame.setRightHand(dtoFrame.getRightHand());&#10;                        return docFrame;&#10;                    }).collect(Collectors.toList());&#10;            motionDataDocument.setHandLandmarks(landmarksFrames);&#10;        }&#10;&#10;        // 최종 Document 객체 생성&#10;        RecordedMotionDocument document = RecordedMotionDocument.builder()&#10;                .userId(mockUserId)&#10;                .phrase(requestDTO.getPhrase())&#10;                .motionType(requestDTO.getMotionType())&#10;                .motionData(motionDataDocument)&#10;                .build();&#10;&#10;        // DB에 저장&#10;        recordedMotionRepository.save(document);&#10;&#10;        log.info(&quot;[MotionService] Motion saved successfully! recordId: {}&quot;, document.getRecordId());&#10;    }&#10;&#10;    @Override&#10;    public String sendMotionVideoToFastAPI(&#10;            String phrase,&#10;            String detectionArea,&#10;            org.springframework.web.multipart.MultipartFile videoFile,&#10;            String trimStart,&#10;            String trimEnd&#10;    ) {&#10;        log.info(&quot;[MotionService] Streaming FFmpeg → FastAPI (no output file): phrase={}, area={}, ss={}, to={}&quot;,&#10;                phrase, detectionArea, trimStart, trimEnd);&#10;&#10;        // Build a pipe: FFmpeg writes to ffOut, HTTP reads from ffIn&#10;        final int PIPE_BUF = 1 &lt;&lt; 20; // 1MB pipe buffer helps smooth backpressure&#10;        try (PipedOutputStream ffOut = new PipedOutputStream();&#10;             PipedInputStream ffIn  = new PipedInputStream(ffOut, PIPE_BUF);&#10;             CloseableHttpClient httpClient = HttpClients.custom().build()) {&#10;&#10;            // ---- 1) Kick off FFmpeg in a background thread&#10;            var es = java.util.concurrent.Executors.newSingleThreadExecutor();&#10;            var ffTask = es.submit(() -&gt; {&#10;                try (var inStream = videoFile.getInputStream()) {&#10;                    // Use the uploaded stream as FFmpeg input (no temp file)&#10;                    var input = com.github.kokorin.jaffree.ffmpeg.PipeInput.pumpFrom(inStream)&#10;                            // If input is WebM (typical from MediaRecorder), set format:&#10;                            .setFormat(&quot;webm&quot;);&#10;&#10;                    var out = com.github.kokorin.jaffree.ffmpeg.PipeOutput.pumpTo(ffOut)&#10;                            .setCodec(StreamType.VIDEO, &quot;copy&quot;)&#10;                            .setCodec(StreamType.AUDIO, &quot;libopus&quot;) // re-encode audio for compatibility&#10;                            .addArgument(&quot;-f&quot;).addArgument(&quot;webm&quot;);&#10;&#10;                    var ff = FFmpeg.atPath(); // if ffmpeg isn't on PATH: FFmpeg.atPath(Paths.get(&quot;C:\\ffmpeg\\bin&quot;))&#10;&#10;                    ff.addInput(input);&#10;&#10;                    if (trimStart != null &amp;&amp; !trimStart.isBlank()) {&#10;                        ff.addArgument(&quot;-ss&quot;).addArgument(trimStart);&#10;                    }&#10;                    if (trimEnd != null &amp;&amp; !trimEnd.isBlank()) {&#10;                        ff.addArgument(&quot;-to&quot;).addArgument(trimEnd);&#10;                    }&#10;&#10;                    ff.addOutput(out).execute();&#10;                } catch (Exception e) {&#10;                    log.error(&quot;[MotionService] FFmpeg streaming failed&quot;, e);&#10;                    // If FFmpeg fails, make sure to close the pipe so the HTTP layer sees EOF&#10;                } finally {&#10;                    try { ffOut.close(); } catch (Exception ignore) {}&#10;                }&#10;            });&#10;&#10;            // ---- 2) Build a streaming multipart request to FastAPI&#10;            var filePart = new InputStreamResource(ffIn) {&#10;                @Override public String getFilename() { return &quot;motion.webm&quot;; } // give it a name&#10;                @Override public long contentLength() { return -1; }           // unknown → chunked&#10;            };&#10;&#10;            var body = new LinkedMultiValueMap&lt;String, Object&gt;();&#10;            body.add(&quot;phrase&quot;, phrase);&#10;            body.add(&quot;detectionArea&quot;, detectionArea);&#10;            body.add(&quot;videoFile&quot;, filePart);&#10;&#10;            var headers = new HttpHeaders();&#10;            headers.setContentType(MediaType.MULTIPART_FORM_DATA);&#10;&#10;            var requestFactory = new org.springframework.http.client.HttpComponentsClientHttpRequestFactory(httpClient);&#10;            requestFactory.setConnectTimeout(10_000);&#10;            requestFactory.setReadTimeout(120_000);&#10;&#10;            // Important: with InputStreamResource + unknown length, HC5 will stream chunked&#10;            var rest = new org.springframework.web.client.RestTemplate(requestFactory);&#10;            var req  = new HttpEntity&lt;&gt;(body, headers);&#10;&#10;            ResponseEntity&lt;String&gt; resp = rest.exchange(&#10;                    &quot;http://localhost:8000/api/process-motion&quot;,&#10;                    HttpMethod.POST,&#10;                    req,&#10;                    String.class&#10;            );&#10;&#10;            // Wait for ffmpeg thread to finish (or time out)&#10;            try { ffTask.get(2, java.util.concurrent.TimeUnit.MINUTES); }&#10;            catch (Exception e) { ffTask.cancel(true); }&#10;&#10;            es.shutdownNow();&#10;&#10;            log.info(&quot;[MotionService] FastAPI status={}, bodyLen={}&quot;,&#10;                    resp.getStatusCode(), (resp.getBody() == null ? 0 : resp.getBody().length()));&#10;&#10;            return resp.getBody();&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;[MotionService] I/O error during streaming&quot;, e);&#10;            return &quot;Error: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String sendMotionVideoToFastAPI(String phrase, String detectionArea, org.springframework.web.multipart.MultipartFile videoFile) {&#10;        // Delegate to the main method with null trimStart/trimEnd&#10;        return sendMotionVideoToFastAPI(phrase, detectionArea, videoFile, null, null);&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package kopo.motionservice.service.impl;&#10;&#10;import com.github.kokorin.jaffree.ffmpeg.FFmpeg;&#10;import com.github.kokorin.jaffree.StreamType;&#10;import com.github.kokorin.jaffree.ffmpeg.UrlInput;&#10;import com.github.kokorin.jaffree.ffmpeg.UrlOutput;&#10;import kopo.motionservice.dto.MotionRecordRequestDTO;&#10;import kopo.motionservice.repository.RecordedMotionRepository;&#10;import kopo.motionservice.repository.document.RecordedMotionDocument;&#10;import kopo.motionservice.service.IMotionService;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;&#10;import org.apache.hc.client5.http.impl.classic.HttpClients;&#10;import org.springframework.core.io.InputStreamResource;&#10;import org.springframework.http.HttpEntity;&#10;import org.springframework.http.HttpHeaders;&#10;import org.springframework.http.HttpMethod;&#10;import org.springframework.http.MediaType;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.util.LinkedMultiValueMap;&#10;import org.springframework.util.MultiValueMap;&#10;&#10;import java.io.IOException;&#10;import java.io.PipedInputStream;&#10;import java.io.PipedOutputStream;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;import java.util.stream.Collectors;&#10;&#10;@Slf4j&#10;@Service&#10;@RequiredArgsConstructor&#10;public class MotionServiceImpl implements IMotionService {&#10;&#10;    private final RecordedMotionRepository recordedMotionRepository;&#10;&#10;    @Override&#10;    public void saveRecordedMotion(MotionRecordRequestDTO requestDTO) {&#10;        log.info(&quot;[MotionService] Manual Mapping - Saving recorded motion for phrase: {}&quot;, requestDTO.getPhrase());&#10;&#10;        // TODO: JWT 인증 구현 후, 토큰에서 실제 userId를 가져와야 합니다.&#10;        String mockUserId = &quot;user123&quot;;&#10;&#10;        // DTO -&gt; Document 수동 매핑 시작&#10;        MotionRecordRequestDTO.MotionDataDTO motionDataDTO = requestDTO.getMotionData();&#10;        RecordedMotionDocument.MotionDataDocument motionDataDocument = new RecordedMotionDocument.MotionDataDocument();&#10;&#10;        if (motionDataDTO != null) {&#10;            // face_blendshapes 수동 매핑&#10;            List&lt;RecordedMotionDocument.FaceBlendshapesFrameDocument&gt; blendshapesFrames = Optional.ofNullable(motionDataDTO.getFaceBlendshapes()).orElse(new ArrayList&lt;&gt;()).stream()&#10;                    .map(dtoFrame -&gt; {&#10;                        RecordedMotionDocument.FaceBlendshapesFrameDocument docFrame = new RecordedMotionDocument.FaceBlendshapesFrameDocument();&#10;                        docFrame.setTimestampMs(dtoFrame.getTimestampMs());&#10;                        docFrame.setValues(dtoFrame.getValues());&#10;                        return docFrame;&#10;                    }).collect(Collectors.toList());&#10;            motionDataDocument.setFaceBlendshapes(blendshapesFrames);&#10;&#10;            // hand_landmarks 수동 매핑&#10;            List&lt;RecordedMotionDocument.HandLandmarksFrameDocument&gt; landmarksFrames = Optional.ofNullable(motionDataDTO.getHandLandmarks()).orElse(new ArrayList&lt;&gt;()).stream()&#10;                    .map(dtoFrame -&gt; {&#10;                        RecordedMotionDocument.HandLandmarksFrameDocument docFrame = new RecordedMotionDocument.HandLandmarksFrameDocument();&#10;                        docFrame.setTimestampMs(dtoFrame.getTimestampMs());&#10;                        docFrame.setLeftHand(dtoFrame.getLeftHand());&#10;                        docFrame.setRightHand(dtoFrame.getRightHand());&#10;                        return docFrame;&#10;                    }).collect(Collectors.toList());&#10;            motionDataDocument.setHandLandmarks(landmarksFrames);&#10;        }&#10;&#10;        // 최종 Document 객체 생성&#10;        RecordedMotionDocument document = RecordedMotionDocument.builder()&#10;                .userId(mockUserId)&#10;                .phrase(requestDTO.getPhrase())&#10;                .motionType(requestDTO.getMotionType())&#10;                .motionData(motionDataDocument)&#10;                .build();&#10;&#10;        // DB에 저장&#10;        recordedMotionRepository.save(document);&#10;&#10;        log.info(&quot;[MotionService] Motion saved successfully! recordId: {}&quot;, document.getRecordId());&#10;    }&#10;&#10;    @Override&#10;    public String sendMotionVideoToFastAPI(&#10;            String phrase,&#10;            String detectionArea,&#10;            org.springframework.web.multipart.MultipartFile videoFile,&#10;            String trimStart,&#10;            String trimEnd&#10;    ) {&#10;        log.info(&quot;[MotionService] Streaming FFmpeg → FastAPI (no output file): phrase={}, area={}, ss={}, to={}&quot;,&#10;                phrase, detectionArea, trimStart, trimEnd);&#10;&#10;        // Build a pipe: FFmpeg writes to ffOut, HTTP reads from ffIn&#10;        final int PIPE_BUF = 1 &lt;&lt; 20; // 1MB pipe buffer helps smooth backpressure&#10;        try (PipedOutputStream ffOut = new PipedOutputStream();&#10;             PipedInputStream ffIn  = new PipedInputStream(ffOut, PIPE_BUF);&#10;             CloseableHttpClient httpClient = HttpClients.custom().build()) {&#10;&#10;            // ---- 1) Kick off FFmpeg in a background thread&#10;            var es = java.util.concurrent.Executors.newSingleThreadExecutor();&#10;            var ffTask = es.submit(() -&gt; {&#10;                try (var inStream = videoFile.getInputStream()) {&#10;                    // Use the uploaded stream as FFmpeg input (no temp file)&#10;                    var input = com.github.kokorin.jaffree.ffmpeg.PipeInput.pumpFrom(inStream)&#10;                            // If input is WebM (typical from MediaRecorder), set format:&#10;                            .setFormat(&quot;webm&quot;);&#10;&#10;                    var out = com.github.kokorin.jaffree.ffmpeg.PipeOutput.pumpTo(ffOut)&#10;                            .setCodec(StreamType.VIDEO, &quot;copy&quot;)&#10;                            .setCodec(StreamType.AUDIO, &quot;libopus&quot;) // re-encode audio for compatibility&#10;                            .addArgument(&quot;-f&quot;).addArgument(&quot;webm&quot;);&#10;&#10;                    var ff = FFmpeg.atPath(); // if ffmpeg isn't on PATH: FFmpeg.atPath(Paths.get(&quot;C:\\ffmpeg\\bin&quot;))&#10;&#10;                    ff.addInput(input);&#10;&#10;                    if (trimStart != null &amp;&amp; !trimStart.isBlank()) {&#10;                        ff.addArgument(&quot;-ss&quot;).addArgument(trimStart);&#10;                    }&#10;                    if (trimEnd != null &amp;&amp; !trimEnd.isBlank()) {&#10;                        ff.addArgument(&quot;-to&quot;).addArgument(trimEnd);&#10;                    }&#10;&#10;                    ff.addOutput(out).execute();&#10;                } catch (Exception e) {&#10;                    log.error(&quot;[MotionService] FFmpeg streaming failed&quot;, e);&#10;                    // If FFmpeg fails, make sure to close the pipe so the HTTP layer sees EOF&#10;                } finally {&#10;                    try { ffOut.close(); } catch (Exception ignore) {}&#10;                }&#10;            });&#10;&#10;            // ---- 2) Build a streaming multipart request to FastAPI&#10;            var filePart = new InputStreamResource(ffIn) {&#10;                @Override public String getFilename() { return &quot;motion.webm&quot;; } // give it a name&#10;                @Override public long contentLength() { return -1; }           // unknown → chunked&#10;            };&#10;&#10;            var body = new LinkedMultiValueMap&lt;String, Object&gt;();&#10;            body.add(&quot;phrase&quot;, phrase);&#10;            body.add(&quot;detectionArea&quot;, detectionArea);&#10;            body.add(&quot;videoFile&quot;, filePart);&#10;&#10;            var headers = new HttpHeaders();&#10;            headers.setContentType(MediaType.MULTIPART_FORM_DATA);&#10;&#10;            var requestFactory = new org.springframework.http.client.HttpComponentsClientHttpRequestFactory(httpClient);&#10;            requestFactory.setConnectTimeout(10_000);&#10;            requestFactory.setReadTimeout(120_000);&#10;&#10;            // Important: with InputStreamResource + unknown length, HC5 will stream chunked&#10;            var rest = new org.springframework.web.client.RestTemplate(requestFactory);&#10;            var req  = new HttpEntity&lt;&gt;(body, headers);&#10;&#10;            ResponseEntity&lt;String&gt; resp = rest.exchange(&#10;                    &quot;http://localhost:8000/api/process-motion&quot;,&#10;                    HttpMethod.POST,&#10;                    req,&#10;                    String.class&#10;            );&#10;&#10;            // Wait for ffmpeg thread to finish (or time out)&#10;            try { ffTask.get(2, java.util.concurrent.TimeUnit.MINUTES); }&#10;            catch (Exception e) { ffTask.cancel(true); }&#10;&#10;            es.shutdownNow();&#10;&#10;            log.info(&quot;[MotionService] FastAPI status={}, bodyLen={}&quot;,&#10;                    resp.getStatusCode(), (resp.getBody() == null ? 0 : resp.getBody().length()));&#10;&#10;            return resp.getBody();&#10;&#10;        } catch (IOException e) {&#10;            log.error(&quot;[MotionService] I/O error during streaming&quot;, e);&#10;            return &quot;Error: &quot; + e.getMessage();&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public String sendMotionVideoToFastAPI(String phrase, String detectionArea, org.springframework.web.multipart.MultipartFile videoFile) {&#10;        // Delegate to the main method with null trimStart/trimEnd&#10;        return sendMotionVideoToFastAPI(phrase, detectionArea, videoFile, null, null);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/UserService/src/main/java/kopo/userservice/repository/UserInfoRepository.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/UserService/src/main/java/kopo/userservice/repository/UserInfoRepository.java" />
              <option name="originalContent" value="package kopo.userservice.repository;&#10;&#10;public interface UserInfoRepository {&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>